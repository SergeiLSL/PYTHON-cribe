"""
Чтобы разобраться с применением дека, решим задачу определения
палиндрома (https://stepik.org/lesson/219715/step/11?unit=211832).

Или  2.1 Стандартные функции и методы., Задача №9
Решая задачу, до написания кода полезно разложить ее на подзадачи
и составить алгоритм. Обозначим последовательность действий:
    удалим пробелы, переведем строку в нижний регистр, а затем – в список символов;
    поочередно добавим каждый символ в “хвост” дека;
    после добавления всех символов в “голове” дека – первый символ строки,
    а в “хвосте” – последний;
    пока дек не пустой или не содержит единственный элемент, удаляем
    элементы сразу и из “хвоста”, и из “головы” и сравниваем их.
    Если символы одинаковые, повторяем этот шаг. Если различные,
    останавливаем программу;
    если после выполнения цикла дек пуст или содержит единственный элемент,
    то строка является палиндромом, иначе – нет.

Теперь реализуем этот алгоритм на Python.
"""
"""
Задача Палиндром
Определите, является ли введенная строка палиндромом. Выведите YES, если это так, иначе NO.

Sample Input:
Аргентина манит негра

Sample Output:
YES
"""
from collections import deque

items = deque(["Стейк", "Салат", "Десерт"])
print(items)

"""
https://docs.python.org/3.7/library/collections.html#deque-objects

class collections.deque( [ iterable [ , maxlen ] ] ) 
Возвращает новый объект двухсторонней очереди, инициализированный слева направо 
(с использованием append()) данными из итерируемого объекта . Если итерабельность 
не указана, новая двухсторонняя очередь пуста.

Deques - это обобщение стеков и очередей (название произносится «колода» и 
является сокращением от «двусторонней очереди»). Deques поддерживают потокобезопасные, 
эффективные с точки зрения памяти добавления и извлечения с обеих сторон двухсторонней 
очереди с примерно одинаковой производительностью O (1) в любом направлении.

Хотя listобъекты поддерживают подобные операции, они оптимизированы для операций 
быстро фиксированной длиной , и затраты на движение понесет О (п) памяти для pop(0) 
и операций , которые меняют как размер и положение лежащего в основе представления 
данных.insert(0, v)

Если maxlen не указан или не указан None, двухсторонние очереди могут увеличиваться 
до произвольной длины. В противном случае двухсторонняя очередь ограничена указанной 
максимальной длиной. После заполнения двухсторонней очереди ограниченной длины 
при добавлении новых элементов соответствующее количество элементов удаляется с 
противоположного конца. Декоры ограниченной длины обеспечивают функциональность, 
аналогичную tailфильтру в Unix. Они также полезны для отслеживания транзакций и 
других пулов данных, в которых интересны только самые последние действия.

Объекты Deque поддерживают следующие методы:

append( х ) 
Добавьте x в правую часть двухсторонней очереди.

appendleft( х ) 
Добавьте x в левую часть двухсторонней очереди.

clear( ) 
Удалите все элементы из двухсторонней очереди, оставив ее длину 0.

copy( ) 
Создайте неглубокую копию двухсторонней очереди.

Новое в версии 3.5.

count( х ) 
Подсчитайте количество элементов двухсторонней очереди, равное x .

Новое в версии 3.2.

extend( повторяется ) 
Расширьте правую часть двухсторонней очереди, добавив элементы из повторяемого аргумента.

extendleft( повторяется ) 
Расширьте левую часть двухсторонней очереди, добавив элементы из iterable . 
Обратите внимание, что последовательность левых добавлений приводит к изменению 
порядка элементов в повторяемом аргументе.

index( x [ , start [ , stop ] ] ) 
Возвращает позицию x в двухсторонней очереди (в начале индекса или после 
него и до остановки индекса ). Возвращает первое совпадение или повышает, ValueError
если не найдено.

Новое в версии 3.5.

insert( i , х ) 
Вставьте x в двухстороннюю очередь в позиции i .

Если вставка вызовет рост ограниченной двухсторонней очереди за пределы maxlen , IndexError поднимается.

Новое в версии 3.5.

pop( ) 
Удалите и верните элемент с правой стороны двухсторонней очереди. 
Если никаких элементов нет, вызывает IndexError.

popleft( ) 
Удалите и верните элемент из левой части двухсторонней очереди. 
Если никаких элементов нет, вызывает IndexError.

remove( значение ) 
Удалите первое вхождение значения . Если не найден, поднимает ValueError.

reverse( ) 
Поменяйте местами элементы двухсторонней очереди, а затем вернитесь None.

Новое в версии 3.2.

rotate( n = 1 ) 
Поверните deque n шагов вправо. Если n отрицательное, поверните влево.

Когда двухсторонняя очередь не пуста, поворот на один шаг вправо 
эквивалентен d.appendleft(d.pop()), а поворот на один шаг влево эквивалентен d.append(d.popleft()).

Объекты Deque также предоставляют один атрибут только для чтения:

maxlen
Максимальный размер двухсторонней очереди или, None если он не ограничен.

Новое в версии 3.1.

В дополнении к вышесказанному, поддерживают итерацию двусторонних очереди, травление, 
len(d), reversed(d), copy.copy(d), copy.deepcopy(d), членство тестирование с inоператором, 
и подстрочными ссылками , такими как d[-1]. Индексированный доступ составляет O (1) 
на обоих концах, но замедляется до O (n) в середине. Вместо этого для быстрого произвольного 
доступа используйте списки.

Начиная с версии 3.5, поддержка двусторонних очередей __add__(), __mul__() и __imul__().

Пример:
"""
from collections import deque

d = deque('ghi')  # make a new deque with three items
for elem in d:  # iterate over the deque's elements
    print(elem.upper())
# G
# H
# I

d.append('j')  # add a new entry to the right side
d.appendleft('f')  # add a new entry to the left side
print(d)  # show the representation of the deque
# deque(['f', 'g', 'h', 'i', 'j'])

d.pop()  # return and remove the rightmost item
# 'j'
d.popleft()  # return and remove the leftmost item
# 'f'
print(list(d))  # list the contents of the deque
# ['g', 'h', 'i']
print(d[0])  # peek at leftmost item
# 'g'
print(d[-1])  # peek at rightmost item
# 'i'

print(list(reversed(d)))  # list the contents of a deque in reverse
# ['i', 'h', 'g']
print('h' in d)  # search the deque
# True
d.extend('jkl')  # add multiple elements at once
print(d)  # deque(['g', 'h', 'i', 'j', 'k', 'l'])
d.rotate(1)  # right rotation
print(d)  # deque(['l', 'g', 'h', 'i', 'j', 'k'])
d.rotate(-1)  # left rotation
print(d)  # deque(['g', 'h', 'i', 'j', 'k', 'l'])

print(deque(reversed(d)))  # make a new deque in reverse order
# deque(['l', 'k', 'j', 'i', 'h', 'g'])
print(d.clear())  # None                      # empty the deque
# d.pop()                          # cannot pop from an empty deque
# Traceback (most recent call last):
# File "<pyshell#6>", line 1, in -toplevel-
# d.pop()
# IndexError: pop from an empty deque

d.extendleft('abc')  # extendleft() reverses the input order
print(d)  # deque(['c', 'b', 'a'])

"""
В этом разделе показаны различные подходы к работе с дека.
Deques с ограниченной длиной обеспечивают функциональность, аналогичную tail фильтру в Unix:
"""


def tail(filename, n=10):
    'Return the last n lines of a file'
    with open(filename) as f:
        return deque(f, n)


"""
ЕЩЕ ОЧЕНЬ МНОГО ИНТЕРЕСНО НА САЙТЕ!
"""