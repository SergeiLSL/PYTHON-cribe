"""
Как получить уникальные элементы списка python.

https://pythonru.com/primery/kak-poluchit-unikalnye-jelementy-spiska-python
"""
"""
Вариант №1. Использование множества (set) для получения элементов
Использование множества (set) — один из вариантов. Он удобен тем, 
что включает только уникальные элементы. После этого множество можно 
обратно превратить в список.

Посмотрим на два способа использования множества и списка. 
Первый — достаточно подробный, но он позволяет увидеть происходящее 
на каждом этапе.
"""
numbers = [1, 2, 2, 3, 3, 4, 5]


def get_unique_numbers(numbers):
    list_of_unique_numbers = []
    unique_numbers = set(numbers)

    for number in unique_numbers:
        list_of_unique_numbers.append(number)

    return list_of_unique_numbers


print(get_unique_numbers(numbers))  # [1, 2, 3, 4, 5]

"""
Разберем, что происходит на каждом этапе. Есть список чисел numbers. 
Передаем его в функцию get_unique_numbers.

Внутри этой функции создается пустой список, который в итоге будет 
включать все уникальные числа. После этого используется set для 
получения уникальных чисел из списка numbers.

unique_numbers = set(numbers)

В итоге имеется перечень из уникальных чисел. Осталось сделать из 
него список. Для этого можно использовать цикл, перебирая каждый из элементов.

for number in unique_numbers:
       list_of_unique_numbers.append(number)
       
На каждой итерации текущее число добавляется в список list_of_unique_numbers. 
Наконец, именно этот список возвращается в конце программы.

Есть и более короткий способ использования множества для получения 
уникальных значений в Python. О нем и пойдет речь дальше.

Короткий вариант с set
Весь код выше можно сжать в одну строку с помощью встроенных в Python функций.
"""
numbers = [1, 2, 2, 3, 3, 4, 5]
unique_numbers = list(set(numbers))
print(unique_numbers)  # [1, 2, 3, 4, 5]

"""
Хотя этот код сильно отличается от первого примера, идея та же. 
Сперва множество используется для получения уникальных значений. 
После этого множество превращается в список.

unique_numbers = list(set(numbers))

Проще всего думать «изнутри наружу» при чтении этого кода. 
Самый вложенный код выполняется первым: set(numbers). 
Затем — внешний блок: list(set(numbers)).

Вариант №2. Использование цикла for
Также стоит рассмотреть подход с использованием цикла.

Для начала нужно создать пустой список, который будет включать 
уникальные числа. После этого можно задействовать цикл для итерации 
по каждому числу в переданном списке. Если число из него есть в уникальном, 
то можно переходить к следующему элементу. 
В противном случае — добавить это число.

Рассмотрим два способа использования цикла. Начнем с более подробного.

КОПИРОВАТЬ
"""
numbers = [20, 20, 30, 30, 40]


def get_unique_numbers(numbers):
    unique = []

    for number in numbers:
        if number in unique:
            continue
        else:
            unique.append(number)
    return unique


print(get_unique_numbers(numbers))  # [20, 30, 40]
"""
print(get_unique_numbers(numbers))
Вот что происходит на каждом этапе. Сначала есть список чисел 
numbers. Он передается в функцию get_unique_numbers.

Внутри этой функции создается пустой список unique. В итоге он будет 
включать все уникальные значения.

Цикл будет использоваться для перебора по числам в списке numbers.

    for number in numbers:
        if number in unique:
            continue
        else:
            unique.append(number)
            
Условные конструкции в цикле проверяют, есть ли число текущей итерации 
в списке unique. Если да, то цикл переходит на следующую итерации. 
Если нет — число добавляется в список.

Важно отметить, что добавляются только уникальные числа. 
Когда цикл завершен, список unique с уникальными числами возвращается.

Короткий способ с циклом
Есть и другой способ использования варианта с циклом, который 
короче на несколько строк.
"""
numbers = [20, 20, 30, 30, 40]


def get_unique_numbers(numbers):
    unique = []
    for number in numbers:
        if number not in unique:
            unique.append(number)
    return unique


print(get_unique_numbers(numbers))  # [20, 30, 40]

"""    
Разница в условной конструкции. В этот раз она следующая — 
если числа нет в unique, то его нужно добавить.

if number not in unique:
    unique.append(number)
        
В противном случае цикл перейдет к следующему числу в списке numbers.

Результат будет тот же. Но иногда подобное читать сложнее, 
когда булево значение опускается.

Есть еще несколько способов поиска уникальных значений в списке Python. 
Но достаточно будет тех, которые описаны в этой статье.
"""
